#include <iostream>
#include <string>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#include <unordered_map>

using namespace std;

struct Task {
    string name;
    int priority;
    Task* next;
    Task(string n, int p) : name(n), priority(p), next(nullptr) {}
};

stack<Task*> undoStack;
unordered_map<string, Task*> taskMap;

struct TaskComparator {
    bool operator()(const Task* a, const Task* b) {
        return a->priority < b->priority;
    }
};

priority_queue<Task*, vector<Task*>, TaskComparator> executionQueue;

class TaskList {
public:
    Task* head;
    TaskList() : head(nullptr) {}

    void add_task(const string& name, int priority) {
        Task* t = new Task(name, priority);
        insert_existing_task(t);
    }

    void insert_existing_task(Task* t) {
        t->next = head;
        head = t;
        taskMap[t->name] = t;
        cout << "Task '" << t->name << "' added." << endl;
    }

    bool remove_task(const string& name, Task*& deleted) {
        Task* prev = nullptr;
        Task* curr = head;
        while (curr) {
            if (curr->name == name) {
                if (prev) prev->next = curr->next;
                else head = curr->next;
                deleted = curr;
                deleted->next = nullptr;
                taskMap.erase(name);
                return true;
            }
            prev = curr;
            curr = curr->next;
        }
        return false;
    }

    void display() {
        Task* curr = head;
        cout << "\nActive Tasks (Recent First): ";
        while (curr) {
            cout << curr->name << "(P" << curr->priority << ")";
            curr = curr->next;
            if (curr) cout << " -> ";
        }
        if (!head) cout << "No active tasks";
        cout << endl;
    }

    void get_all(vector<Task*>& out) {
        Task* curr = head;
        while (curr) {
            out.push_back(curr);
            curr = curr->next;
        }
    }
};

struct TreeNode {
    Task* task;
    TreeNode* left;
    TreeNode* right;
    TreeNode(Task* t) : task(t), left(nullptr), right(nullptr) {}
};

TreeNode* insert(TreeNode* root, Task* t) {
    if (!root) return new TreeNode(t);
    if (t->priority < root->task->priority)
        root->left = insert(root->left, t);
    else
        root->right = insert(root->right, t);
    return root;
}

void inorder(TreeNode* root, vector<Task*>& out) {
    if (!root) return;
    inorder(root->left, out);
    out.push_back(root->task);
    inorder(root->right, out);
}

void delete_tree(TreeNode* root) {
    if (!root) return;
    delete_tree(root->left);
    delete_tree(root->right);
    delete root;
}

class RecurringTaskList {
public:
    Task* head;
    RecurringTaskList() : head(nullptr) {}

    void add_recurring_task(const string& name, int priority) {
        Task* t = new Task(name, priority);
        if (!head) {
            head = t;
            t->next = head;
        } else {
            Task* last = head;
            while (last->next != head) {
                last = last->next;
            }
            last->next = t;
            t->next = head;
        }
        cout << "Recurring task '" << name << "' added." << endl;
    }

    void display_recurring() {
        if (!head) {
            cout << "No recurring tasks." << endl;
            return;
        }
        Task* curr = head;
        cout << "\nRecurring Cycle: ";
        do {
            cout << curr->name << " (P" << curr->priority << ")";
            curr = curr->next;
            if (curr != head) cout << " -> ";
        } while (curr != head);
        cout << endl;
    }

    void cleanup() {
        if (!head) return;
        Task* curr = head->next;
        while (curr != head) {
            Task* nxt = curr->next;
            delete curr;
            curr = nxt;
        }
        delete head;
        head = nullptr;
    }
};

int main() {
    TaskList tasks;
    queue<pair<string, int>> toAdd;
    RecurringTaskList recurringTasks;

    int choice;
    do {
        cout << "\n============================================\n"
             << "ðŸ“… Task Manager Menu (Data Structures Demo)\n"
             << "============================================\n"
             << "1. Add New Task (Queue -> Linked List)\n"
             << "2. Delete a Task (Linked List, updates Hash Map)\n"
             << "3. Undo Last Delete (Stack: LIFO)\n"
             << "4. Display All Active Tasks (Linked List)\n"
             << "5. Display Tasks Sorted by Priority (BST)\n"
             << "6. Quick Search by Name (Hash Table: O(1) avg.)\n"
             << "7. Execute Next High Priority Task (Priority Queue)\n"
             << "8. Add Recurring Task (Circular Linked List)\n"
             << "9. Display Recurring Tasks (Circular Linked List)\n"
             << "0. Exit\n"
             << "Enter choice: ";
        cin >> choice;
        cin.ignore();

        if (choice == 1) {
            string tname;
            int tprio;
            cout << "Enter task name: ";
            getline(cin, tname);
            cout << "Enter priority (integer, higher is more urgent): ";
            cin >> tprio; 
            cin.ignore();
            toAdd.push({tname, tprio});

            auto item = toAdd.front(); 
            toAdd.pop();
            tasks.add_task(item.first, item.second);
        }
        else if (choice == 2) {
            string tname;
            cout << "Enter name of task to delete: ";
            getline(cin, tname);
            Task* deleted = nullptr;
            if (tasks.remove_task(tname, deleted)) {
                undoStack.push(deleted);
                cout << "Task '" << tname << "' deleted and pushed to undo stack." << endl;
            } else {
                cout << "Task not found." << endl;
            }
        }
        else if (choice == 3) {
            if (!undoStack.empty()) {
                Task* t = undoStack.top(); 
                undoStack.pop();
                tasks.insert_existing_task(t);
                cout << "Last deleted task restored." << endl;
            } else {
                cout << "Undo stack is empty." << endl;
            }
        }
        else if (choice == 4) {
            tasks.display();
        }
        else if (choice == 5) {
            TreeNode* root = nullptr;
            vector<Task*> all;
            tasks.get_all(all);
            for (Task* t : all)
                root = insert(root, t);

            vector<Task*> sorted;
            inorder(root, sorted);

            cout << "\nTasks Sorted by Priority (Low -> High):" << endl;
            for (auto t : sorted) cout << t->name << "(P" << t->priority << ") ";
            cout << endl;

            delete_tree(root);
        }
        else if (choice == 6) {
            string tname;
            cout << "Enter name to quick search: ";
            getline(cin, tname);

            if (taskMap.count(tname)) {
                Task* t = taskMap[tname];
                cout << "Task found (Quick Lookup): " << t->name 
                     << " (Priority " << t->priority << ")" << endl;
            } else {
                cout << "Task '" << tname << "' not found." << endl;
            }
        }
        else if (choice == 7) {
            if (tasks.head == nullptr) {
                cout << "No active tasks to execute." << endl;
            } else {
                while (!executionQueue.empty()) executionQueue.pop();
                vector<Task*> all;
                tasks.get_all(all);
                for (Task* t : all) executionQueue.push(t);

                Task* nextTask = executionQueue.top();
                cout << "\n>> Executing High Priority Task: **" << nextTask->name 
                     << "** (Priority " << nextTask->priority << ") <<\n" << endl;

                Task* deleted = nullptr;
                if (tasks.remove_task(nextTask->name, deleted)) {
                    delete deleted;
                }
            }
        }
        else if (choice == 8) {
            string tname;
            int tprio;
            cout << "Enter recurring task name: ";
            getline(cin, tname);
            cout << "Enter priority (integer): ";
            cin >> tprio; 
            cin.ignore();
            recurringTasks.add_recurring_task(tname, tprio);
        }
        else if (choice == 9) {
            recurringTasks.display_recurring();
        }

    } while (choice != 0);

    Task* curr = tasks.head;
    while (curr) {
        Task* nxt = curr->next;
        delete curr;
        curr = nxt;
    }
    while (!undoStack.empty()) {
        delete undoStack.top();
        undoStack.pop();
    }
    recurringTasks.cleanup();

    cout << "\nExiting Task Manager. Memory cleaned up." << endl;
    return 0;
}


